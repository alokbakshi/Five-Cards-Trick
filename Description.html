<blockquote>Real magic refers to the magic that is not real, while the magic that is real, that can actually be done, is not real magic.                                                        --- Daniel Dennett</blockquote>
Magic in most of the tricks is due to the sleight of hand but the beauty of the "five cards trick" written below  is that performing it needs nothing more than the mental calculation.

The trick is performed as follows:

<hr />

Alice and Bob are two magicians with a deck of 52 standard cards with them. Alice comes to you and ask you to pick any <em>five</em> cards. She carefully looks at your choice and then hands you back one card out of those five. Thereafter she takes the remaining four cards and give those to the Bob.

Note that it's only Alice's prerogative to choose the handed over card. Moreover Bob is standing away and no information is passed to him with the exception of <em>ordered</em> list of remaining four cards.

Thereafter Bob does some mental calculation -- while chanting abracadabra simultaneously -- and correctly figures out the fifth card, which you have safely kept away from his eye.

<hr />

Before discussing the solution (you can read it <a href="https://puzzling.stackexchange.com/questions/6569/a-five-card-trick-how-does-it-work" target="_blank" rel="noopener">here</a>) let us rephrase the problem in mathematical terms. There is an one-to-one correspondence between deck of fifty two cards and set of natural numbers between 0 and 51 (both endpoints included). For example, we may number cards of Club suit between 0 and 12, cards of Diamond suit between 13 and 25, and so on.

Getting back to the problem, in the new representation, it can be rephrased as follows:

<strong>Given five distinct numbers $latex \displaystyle 0 \leq u, v, x, y, z \leq 51$, find a strategy of choosing $latex \displaystyle u$ such that by looking at the remaining numbers presented in some order, say $latex \displaystyle y, z, x, v$ one can figure out the value of $latex \displaystyle u$.</strong>

For example, if the numbers are 3, 5, 20, 32, 44. Then one can hide the number 5 and give back the ordered list of numbers: 3, 20, 44, 32. By looking at this list, you're supposed to deduce that the hidden number is 5.

Before looking at the solution and refining it thereafter, let us first try to see if the naive (definition of 'naive' or 'intuitive' differs from person to person) approach can lead us somewhere.

One can immediately see that remaining four numbers can be arranged in $latex 4! = 24$ different ways. On the other hand, there are 48 distinct possibilities for the fifth number (as four out of fifty two numbers are already known). Thus one needs to hide that particular number, whose number of possibilities stay within twenty four.

As an example, one might simply choose to hide the median $latex \displaystyle x_3$ out of the five numbers $latex \displaystyle 0 \leq x_1 < x_2 < x_3 < x_4 < x_5 \leq 51$. Thus with the remaining four numbers $latex \displaystyle 0 \leq x_1 < x_2 < x_4 < x_5 \leq 51$, one can specify $latex \displaystyle x_3$ from the permutations of remaining four only if $latex \displaystyle |x_4 - x_2| \leq 25$. So we see that this naive approach is not foolproof. Similarly one can try other 'simple' strategies (say, always hide the extreme number) but they will not succeed in every possible situation.

Thus relative ordering of the numbers does not provide enough information and we need to incorporate their magnitudes into our calculation as well. Having (hopefully) realized the difficulty of problem, let us look at one of the elegant solution, which is an application of <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle" target="_blank" rel="noopener">Pigeonhole </a>principle. To apply it, let us partition the collection of numbers into four equal sized sets, namely:
<p style="text-align: center;">$latex \displaystyle A = \{n \in \mathbb{N} \ | \ 0 \leq n \leq 12\}, \ \   B = \{n \in \mathbb{N} \ | \ 13 \leq n \leq 25\}$</p>
<p style="text-align: center;">$latex \displaystyle C = \{n \in \mathbb{N} \ | \ 26 \leq n \leq 38\}, \ \   D = \{n \in \mathbb{N} \ | \ 39 \leq n \leq 51\}$</p>
then out of five numbers, two of them will definitely fall into the same set, which for the sake of definiteness we take as $latex \displaystyle B$.

Thus suppose that $latex \displaystyle x, y, z, u, v$ are the five distinct numbers with $latex \displaystyle u, v \in B$ and therefore $latex \displaystyle |u - v| \leq |B| = 13$. In that case we can choose to hide either of $latex \displaystyle u \mbox{ or } v$ and put the other on top (or other previously specified location) of the returned ordered list of numbers. Thus we can immediately narrow down our search to the list of twelve numbers (as  $latex \displaystyle |u - v| \leq 13$ and $latex \displaystyle u, v$ are distinct). Having already fixed the position of one in the returned list of four numbers, we can rearrange the remaining numbers in $latex \displaystyle 3! = 6$ distinct ways. It is impossible to represent twelve numbers out of these six distinct cases. But if we choose the hidden number (out of two candidates $latex \displaystyle u$ and $latex \displaystyle v$) cleverly then we can narrow our search further down from twelve to six. To that end, we equip the set $latex \displaystyle B$ with the modular arithmetic operation
<p style="text-align: center;">$latex \displaystyle  x \oplus y := \ \ 13 + \left( x + y \right) \% 13$</p>
(i.e. mentally picture it as an 13 hour clock where digits run between 13 and 25) then either $latex \displaystyle u$ lies within six units right (or clockwise) to $latex \displaystyle v$ or $latex \displaystyle v$ lies within six units right to $latex \displaystyle u$. Thus by hiding the appropriate number, we can make sure that it is within six units right to the topmost number of the returned list of four numbers. Moreover the actual offset can then be conveniently represented by the permutation of the remaining three numbers. For example, the offset ($latex \displaystyle 1 \leq \mathrm{offset} \leq 6$) can be read from the ordered returned list of remaining three numbers $latex \displaystyle \{x, y, z\}$ as follows:
<ul>
	<li style="text-align: center;">$latex \displaystyle x < y < z \qquad \longleftrightarrow \qquad \mathrm{offset} = 1$</li>
	<li style="text-align: center;">$latex \displaystyle x < z < y \qquad \longleftrightarrow \qquad \mathrm{offset} = 2$</li>
	<li style="text-align: center;">$latex \displaystyle y < x < z \qquad \longleftrightarrow \qquad \mathrm{offset} = 3$</li>
	<li style="text-align: center;">$latex \displaystyle y < z < x \qquad \longleftrightarrow \qquad \mathrm{offset} = 4$</li>
	<li style="text-align: center;">$latex \displaystyle z < x < y \qquad \longleftrightarrow \qquad \mathrm{offset} = 5$</li>
	<li style="text-align: center;">$latex \displaystyle z < y < x \qquad \longleftrightarrow \qquad \mathrm{offset} = 6$</li>
</ul>
Here is an illustrative example:

<hr />

Suppose that your chosen five numbers are 3, 22, 26, 34, 44. Then Alice will notice that numbers 26 and 34 belong to the same set $latex \displaystyle C$. Moreover the number 26 is at a distance of 5 to the right of 34 as
<p style="text-align: center;">$latex \displaystyle 34 \rightarrow 35 \rightarrow 36 \rightarrow 37 \rightarrow 38 \rightarrow 26$</p>
Also she notes that 34 is at a distance of 8 units to the right of 26, that's why she had to go the other way around. So she will hide the number 26 and put 34 on top of the returned list of four numbers. Now she also need to encode the offset 5 in terms of the permutation of remaining three numbers (namely 3, 22, 44).  According to the list above it means, that she needs to put that in the order of (44, 3, 22). Thus she will arrange the remaining four numbers as (34, 44, 3, 22) and give that to Bob.

Afterwards Bob, receiving these four numbers can immediately decode it to find the missing number.

<hr />

As you may have guessed earlier, partitioning 52 numbers into 4 sets correspond to the classification of playing cards in terms of their suits. One might wonder about the utility of thinking cards in terms of numbers at all but looking the problem in this way makes it amenable to further generalization.

We can in fact improve upon this method (explained <a href="http://www.apprendre-en-ligne.net/crypto/magie/card.pdf" target="_blank" rel="noopener">here</a>), which will be topic of the next post. In the meantime, you can see a crude $latex \displaystyle C \texttt{++}$ program which realizes the above algorithm in case of playing a standard deck of 52 cards.

<hr />

[code language="cpp"]
#include <iostream>
#include <iomanip>
#include <utility>
#include <array>
#include <algorithm>
#include <cmath>

constexpr int CARDS_PER_SUIT = 13;
constexpr int CARDS_IN_HANDS = 5;

constexpr int SUITS = 4;
constexpr int CARDS = SUITS * CARDS_PER_SUIT;

enum Suit {
	CLUB = 0, DIAMOND, HEART, SPADE
};

enum Symbol {
	ACE = 0, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING
};

struct Card {
	Suit suit;
	Symbol symbol;

	friend std::ostream& operator <<(std::ostream& stream, const Card& card);

};

std::ostream& operator <<(std::ostream& stream, const Card& card) {
	const char* suit_text = "";
	const char* symbol_text = "";

	Symbol symbol = card.symbol;
	Suit suit = card.suit;

	switch (suit) {
	case Suit::CLUB: suit_text = "Club"; break;
	case Suit::DIAMOND: suit_text = "Diamond"; break;
	case Suit::HEART: suit_text = "Heart"; break;
	case Suit::SPADE: suit_text = "Spade"; break;
	}

	switch (symbol) {
	case Symbol::ACE: symbol_text = "Ace"; break;
	case Symbol::TWO: symbol_text = "Two"; break;
	case Symbol::THREE: symbol_text = "Three"; break;
	case Symbol::FOUR: symbol_text = "Four"; break;
	case Symbol::FIVE: symbol_text = "Five"; break;
	case Symbol::SIX: symbol_text = "Six"; break;
	case Symbol::SEVEN: symbol_text = "Seven"; break;
	case Symbol::EIGHT: symbol_text = "Eight"; break;
	case Symbol::NINE: symbol_text = "Nine"; break;
	case Symbol::TEN: symbol_text = "Ten"; break;
	case Symbol::JACK: symbol_text = "Jack"; break;
	case Symbol::QUEEN: symbol_text = "Queen"; break;
	case Symbol::KING: symbol_text = "King"; break;
	}

	stream << "Suit: " << std::setw(7) << suit_text << ",\tSymbol: " << std::setw(4) << symbol_text << "\n";
	return stream;
}

int get_code(const Card& card) {
	return (CARDS_PER_SUIT * card.suit) + card.symbol;
}

Card get_card(int code) {
	if ((code < 0) || (code >= 52))
		throw std::invalid_argument("Code must be an integer between 0 and 51 (inclusive)\n");

	Card result;

	result.suit = static_cast<Suit> (code / 13);
	result.symbol = static_cast<Symbol> (code % 13);

	return result;
}

bool compare_inc(const Card& card1, const Card& card2) {
	return (get_code(card1) < get_code(card2));
}

bool compare_dec(const Card& card1, const Card& card2) {
	return !compare_inc(card1, card2);
}

/* Sequence code is a number between 1 and 6 (inclusive) representing the
permutation of three input cards */

int seq_code(const Card& card1, const Card& card2, const Card& card3) {

	bool card1_less_card2 = compare_inc(card1, card2);
	bool card2_less_card3 = compare_inc(card2, card3);
	bool card1_less_card3 = compare_inc(card1, card3);

	int result = 0;

	if (card1_less_card2 && card2_less_card3 && card1_less_card3)
		result = 1;
	else if (card1_less_card2 && !card2_less_card3 && card1_less_card3)
		result = 2;
	else if (!card1_less_card2 && card2_less_card3 && card1_less_card3)
		result = 3;
	else if (card1_less_card2 && !card2_less_card3 && !card1_less_card3)
		result = 4;
	else if (!card1_less_card2 && card2_less_card3 && !card1_less_card3)
		result = 5;
	else if (!card1_less_card2 && !card2_less_card3 && !card1_less_card3)
		result = 6;
	else
		result = 0; // should not really happen!

	return result;

}

Card guess_card(const Card& card1, const Card& card2, const Card& card3, const Card& card4) {

	Card guess; 

	//Suit of unknown card is same as the suit of topmost card
	guess.suit = card1.suit;

	//Read the offset from permutation of remaining three cards
	int offset = seq_code(card2, card3, card4);
	guess.symbol = static_cast<Symbol>((card1.symbol - offset + CARDS_PER_SUIT) % CARDS_PER_SUIT);

	return guess;

}

/* Place the "card to be hidden" on top so that it is within six
units away from the second card on the pile */

void unknown_card_on_top(std::array<Card, CARDS_IN_HANDS>& cards) {

     std::sort(cards.begin(), cards.end(), [](const Card& card1, const Card&
          card2) {return card1.suit < card2.suit;});

     bool finished = false;
     for (int i = 0; (i < CARDS_IN_HANDS) && (!finished); ++i)
          for (int j = i + 1; (j < CARDS_IN_HANDS) && (!finished); ++j) { 		

               if (cards[i].suit == cards[j].suit) {
                    std::swap(cards[0], cards[i]);
                    std::swap(cards[1], cards[j]);
                    finished = true;
               }
          }
     } 	

     int diff = (cards[1].symbol - cards[0].symbol + CARDS_PER_SUIT) %
          CARDS_PER_SUIT; 	

     if (diff > CARDS_PER_SUIT / 2) {
          std::swap(cards[0], cards[1]);
     }

}

/* Shuffle the card so that topmost card is the card to be hidden while
rest of the cards (in the same order) are to be given to the other magician. */

void shuffle_cards(std::array<Card, CARDS_IN_HANDS>& cards) {

	unknown_card_on_top(cards);

	int code = (cards[1].symbol - cards[0].symbol + CARDS_PER_SUIT) % CARDS_PER_SUIT;

	if(code <= 3)
		std::sort(cards.begin() + 2, cards.end(), compare_inc);
	else
		std::sort(cards.begin() + 2, cards.end(), compare_dec);

	switch (code) {
	case 1: break;
	case 2: std::swap(cards[CARDS_IN_HANDS - 2], cards[CARDS_IN_HANDS - 1]); break;
	case 3: std::swap(cards[CARDS_IN_HANDS - 3], cards[CARDS_IN_HANDS - 2]); break;
	case 4:	std::swap(cards[CARDS_IN_HANDS - 3], cards[CARDS_IN_HANDS - 2]); break;
	case 5:	std::swap(cards[CARDS_IN_HANDS - 2], cards[CARDS_IN_HANDS - 1]); break;
	case 6: break;
	}

}

int main() {

	std::cout << "\n\nFive Card Puzzle!\n\n";

	std::array<Card, CARDS_IN_HANDS> cards;

	/* Sample Assignment of Cards to Alice*/

	cards[0].suit = Suit::CLUB;
	cards[1].suit = Suit::HEART;
	cards[2].suit = Suit::DIAMOND;
	cards[3].suit = Suit::CLUB;
	cards[4].suit = Suit::SPADE;

	cards[0].symbol = Symbol::ACE;
	cards[1].symbol = Symbol::FIVE;
	cards[2].symbol = Symbol::JACK;
	cards[3].symbol = Symbol::QUEEN;
	cards[4].symbol = Symbol::KING;

	/************************************/

	std::cout << "Cards given to Alice: \n";
	for (Card& card : cards)
		std::cout << card;

	// Alice rearranges cards (while pretending to shuffle) using some algorithm, and hides the topmost card
	shuffle_cards(cards);
	std::cout << "\n\nHidden card by Alice: \n" << cards[0];

	std::cout << "\nCards given back to Bob: \n";
	// Cards available to Bob
	for (int i=1; i< CARDS_IN_HANDS; ++i)
		std::cout << cards[i];

	// Hidden Card (cards[0] originally) guessed by Bob
	Card guess = guess_card(cards[1], cards[2], cards[3], cards[4]); 

	std::cout << "\n\nGuessed Card:\n" << guess << std::endl;

	return (0);

}
[/code]
